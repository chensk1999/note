# 基本语法

正则表达式是描述某种模式的字符串，可以用来匹配符合特定规则的字符，比如，`([1-9]|1[0-2])`匹配1到12之间的数字

- 或：`|`，具有最低优先级，如`a|b`可以匹配a或者b
- 一般字符：匹配自身，比如`a`
- 字符集合（character class）：匹配其中任意一个，比如`[abc]`匹配a、b、c中任一个；也可以用如`[0-9a-z]`的方式指定字符范围
- 排除型字符集合（negated character class）：列表未列出的字符，如`[^abc]`匹配abc以外的字符
- 元字符（metacharacter）：具有特殊意义的专用字符

## 常用元字符

**普通字符**

| 字符 | 匹配内容                               |
| ---- | -------------------------------------- |
| `.`  | 任意一个字符（除换行符）               |
| `\d` | 数字                                   |
| `\s` | 空白符（` \n\t`等）                    |
| `\w` | 单词字符（字母、数字、下划线、汉字等） |

注：大写匹配相反内容，如`\D`匹配非数字字符

**重复**

| 字符     | 匹配内容          |
| -------- | ----------------- |
| `*`      | 任意数量（包括0） |
| `{n}`    | n个               |
| `{n,}`   | n个或更多个       |
| `{n, m}` | n到m个            |
| `?`      | 0或1个，`{0,1}`   |
| `+`      | 1或更多，`{1,}`   |

如`[a-z]+`匹配1或更多个小写字母

**边界匹配**

| 字符 | 匹配内容                         |
| ---- | -------------------------------- |
| `^`  | 字符串开始位置，或一行的开始     |
| `$`  | 字符串结束位置，或一行的结束     |
| `\b` | 单词开始与结束（`\w`与`\W`之间） |

## 转义字符

有些字符需要用反斜杠转义（`^$()*+?.[\{|`共12个）。比如，`.`匹配任意一个字符，`\.`匹配句点

还可以用编码匹配字符序列，`\xhh`匹配两位十六进制数`hh`匹配的ascii编码字符；`\uhhhh`匹配四位十六进制数`hhhh`匹配的unicode字符

# 分组

用小括号括起来的部分称作分组，分组捕获的内容可以在其他地方进一步处理，如：`([1-9]|1[0-2])-(\d{1,2})`，第一个分组匹配1~12之间的数字，第二个分组匹配1~2位数字，可用这个正则表达式提取月份和日期

## 后向引用

后向引用搜索前面分组匹配的文本，如`(\w+)\s+\1`，其中`\1`匹配第一个分组的文本，此表达式可以匹配一个单词重复两次，比如`go go`

也可以显式给分组命名，如`(?<Word>\w+)\s+\k<Word>`，其中`\k<Word>`匹配第一个分组的文本。尖括号也可以改为单引号

# 零宽断言

零宽断言匹配符合特定条件的位置（因为是位置，所以没有宽度，叫做零宽）

| 表达式     | 名称         | 用途        |
| ---------- | ------------ | ----------- |
| `(?=exp)`  | 先行断言     | 后面是exp   |
| `(?<=exp)` | 后发断言     | 前面是exp   |
| `(?!exp)`  | 负向先行断言 | 后面不是exp |
| `(?<!exp)` | 负向后发断言 | 前面不是exp |

# 懒惰匹配

正则表达式通常进行贪婪匹配，在符合要求的前提下，匹配尽可能多的字符。如，用`a*b`匹配`aabbbab`，它将会匹配最长的以a开始，以b结束的字符串，进而匹配到整个字符串

在重复修饰符后加上一个`?`，变为懒惰匹配，匹配尽可能少的字符。用`a*?b`匹配上述字符串，只匹配到`aab`

但无论用哪种匹配，都是最先开始的匹配拥有最高的优先权（The match that begins earliest wins），因为这个规则，不会匹配到第2、3个字符的ab